---
interface Props {
  code: string;
  className?: string;
}

const { code, className } = Astro.props;
---

<div class={`mermaid ${className || ""}`} data-mermaid={code}>
  <pre><code>{code}</code></pre>
</div>

<script>
  import mermaid from "mermaid";

  // Initialize mermaid with theme support
  function initMermaid() {
    const isDark = document.documentElement.classList.contains("dark");
    
    mermaid.initialize({
      startOnLoad: false,
      theme: isDark ? "dark" : "default",
      themeVariables: isDark
        ? {
            primaryColor: "#a78bfa",
            primaryTextColor: "#e4e4e7",
            primaryBorderColor: "#6366f1",
            lineColor: "#6366f1",
            secondaryColor: "#818cf8",
            tertiaryColor: "#c084fc",
            background: "#18181b",
            mainBkg: "#27272a",
            secondBkg: "#3f3f46",
            tertiaryBkg: "#52525b",
            secondaryBorderColor: "#818cf8",
            tertiaryBorderColor: "#c084fc",
            textColor: "#e4e4e7",
            labelTextColor: "#e4e4e7",
            errorBkgColor: "#991b1b",
            errorTextColor: "#fef2f2",
          }
        : {
            primaryColor: "#6366f1",
            primaryTextColor: "#111827",
            primaryBorderColor: "#4f46e5",
            lineColor: "#4f46e5",
            secondaryColor: "#818cf8",
            tertiaryColor: "#a78bfa",
          },
    });

    // Render all mermaid diagrams
    document.querySelectorAll(".mermaid").forEach((element, index) => {
      const code = element.getAttribute("data-mermaid");
      if (code && !element.getAttribute("data-processed")) {
        element.setAttribute("data-processed", "true");
        element.innerHTML = "";
        const id = `mermaid-${Date.now()}-${index}`;
        mermaid.render(id, code).then(({ svg }) => {
          element.innerHTML = svg;
        }).catch((error) => {
          console.error('Failed to render Mermaid diagram:', error);
          element.innerHTML = `<pre><code>${code}</code></pre>`;
          element.removeAttribute("data-processed");
        });
      }
    });
  }

 let observer: MutationObserver | null = null;

 function cleanup() {
   if (observer) {
     observer.disconnect();
   }
 }
 
  // Initialize on load - with fallback timing
  if (document.readyState === 'loading') {
    document.addEventListener("DOMContentLoaded", initMermaid);
  } else {
    // DOM already loaded, run immediately
    setTimeout(initMermaid, 100);
  }

  // Reinitialize on theme change
  document.addEventListener("astro:after-swap", () => {
    setTimeout(initMermaid, 100);
  });

  // Additional fallback - check after page load
  window.addEventListener("load", () => {
    setTimeout(initMermaid, 200);
  });

  // Cleanup on page unload
  document.addEventListener("astro:before-swap", cleanup);

  // Listen for theme changes
  observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === "class") {
        initMermaid();
      }
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["class"],
  });
</script>

<style>
  .mermaid {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
    background-color: transparent;
  }

  .mermaid pre {
    display: none;
  }

  .mermaid svg {
    max-width: 100%;
    height: auto;
  }
</style>